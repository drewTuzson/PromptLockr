# REPLIT: Epic 6 Phase 2 - Mobile Excellence & Explore Page Implementation

## IMMEDIATE ACTIONS REQUIRED

You are implementing Phase 2 of Epic 6 for PromptLockr. This adds premium mobile web experience (PWA) and community discovery features to the existing system that now has working username, avatar, and sharing functionality from Phase 1.

**CRITICAL**: Follow these instructions sequentially. Do not ask questions - implement exactly as specified.

## CURRENT STATE CONTEXT

Phase 1 completed successfully with:
- ✅ Username system with @mention search
- ✅ Avatar system with generated fallbacks
- ✅ Profile management and user search
- ✅ Privacy controls and sharing system
- ✅ User synchronization between Replit DB and PostgreSQL

## PHASE 2 IMPLEMENTATION GOALS

### Week 4-5: Mobile Excellence & PWA
1. Configure Progressive Web App (PWA) with installable features
2. Implement mobile-first navigation with bottom tabs
3. Create touch-optimized components with swipe actions
4. Add pull-to-refresh functionality
5. Optimize performance for mobile devices

### Week 6-8: Explore & Discovery System
1. Create explore page with trending/new/popular sections
2. Add engagement features (likes, saves, remixes)
3. Build creator profiles with follow system
4. Implement prompt example outputs feature
5. Add advanced filtering and search for discovery

## STEP 1: PWA CONFIGURATION

**CREATE FILE: `public/manifest.json`**

```json
{
  "name": "PromptLockr",
  "short_name": "PromptLockr",
  "description": "AI Prompt Management & Community Platform",
  "start_url": "/dashboard",
  "display": "standalone",
  "orientation": "portrait-primary",
  "theme_color": "#000000",
  "background_color": "#ffffff",
  "scope": "/",
  "lang": "en",
  "categories": ["productivity", "utilities", "developer"],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ],
  "shortcuts": [
    {
      "name": "New Prompt",
      "short_name": "New",
      "description": "Create a new prompt",
      "url": "/dashboard?action=new",
      "icons": [
        {
          "src": "/icons/icon-96x96.png",
          "sizes": "96x96"
        }
      ]
    },
    {
      "name": "Explore",
      "short_name": "Explore",
      "description": "Discover community prompts",
      "url": "/explore",
      "icons": [
        {
          "src": "/icons/icon-96x96.png",
          "sizes": "96x96"
        }
      ]
    }
  ]
}
```

**UPDATE FILE: `index.html`**

Add these lines to the `<head>` section:

```html
<!-- PWA Configuration -->
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#000000">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="PromptLockr">
<link rel="apple-touch-icon" href="/icons/icon-192x192.png">

<!-- Mobile Optimization -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="format-detection" content="telephone=no">
```

## STEP 2: SERVICE WORKER FOR PWA

**CREATE FILE: `public/sw.js`**

```javascript
const CACHE_NAME = 'promptlockr-v1';
const STATIC_CACHE_URLS = [
  '/',
  '/dashboard',
  '/explore',
  '/manifest.json',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
];

// Install event
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        return cache.addAll(STATIC_CACHE_URLS);
      })
      .then(() => {
        return self.skipWaiting();
      })
  );
});

// Activate event
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => {
      return self.clients.claim();
    })
  );
});

// Fetch event
self.addEventListener('fetch', (event) => {
  // Skip cross-origin requests
  if (!event.request.url.startsWith(self.location.origin)) {
    return;
  }

  // API requests - network first, then cache
  if (event.request.url.includes('/api/')) {
    event.respondWith(
      fetch(event.request)
        .then((response) => {
          // Cache successful API responses
          if (response.ok) {
            const responseClone = response.clone();
            caches.open(CACHE_NAME)
              .then((cache) => {
                cache.put(event.request, responseClone);
              });
          }
          return response;
        })
        .catch(() => {
          // Fallback to cache if network fails
          return caches.match(event.request);
        })
    );
    return;
  }

  // Static resources - cache first, then network
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        if (response) {
          return response;
        }
        return fetch(event.request)
          .then((response) => {
            const responseClone = response.clone();
            caches.open(CACHE_NAME)
              .then((cache) => {
                cache.put(event.request, responseClone);
              });
            return response;
          });
      })
  );
});

// Push notification handling
self.addEventListener('push', (event) => {
  const options = {
    body: event.data ? event.data.text() : 'New prompt shared with you!',
    icon: '/icons/icon-192x192.png',
    badge: '/icons/icon-72x72.png',
    vibrate: [200, 100, 200],
    tag: 'promptlockr-notification',
    requireInteraction: true
  };

  event.waitUntil(
    self.registration.showNotification('PromptLockr', options)
  );
});
```

**UPDATE FILE: `client/src/main.tsx`**

Add service worker registration:

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered: ', registration);
      })
      .catch((registrationError) => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}

// PWA install prompt
let deferredPrompt: any;
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredPrompt = e;

  // Show custom install button
  const installButton = document.getElementById('install-button');
  if (installButton) {
    installButton.style.display = 'block';
    installButton.addEventListener('click', () => {
      deferredPrompt.prompt();
      deferredPrompt.userChoice.then((choiceResult: any) => {
        if (choiceResult.outcome === 'accepted') {
          console.log('User accepted the install prompt');
        }
        deferredPrompt = null;
        installButton.style.display = 'none';
      });
    });
  }
});
```

## STEP 3: MOBILE NAVIGATION COMPONENT

**CREATE FILE: `client/src/components/mobile/MobileNavigation.tsx`**

```tsx
import React from 'react';
import { useLocation } from 'wouter';
import { cn } from '@/lib/utils';
import {
  Home,
  Search,
  Plus,
  BookOpen,
  User,
  Bell
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';

interface MobileNavigationProps {
  onCreateClick?: () => void;
  notificationCount?: number;
}

const navigationItems = [
  { id: 'home', label: 'Home', icon: Home, path: '/dashboard' },
  { id: 'explore', label: 'Explore', icon: Search, path: '/explore' },
  { id: 'create', label: 'Create', icon: Plus, path: null }, // Special create button
  { id: 'library', label: 'Library', icon: BookOpen, path: '/dashboard/library' },
  { id: 'profile', label: 'Profile', icon: User, path: '/profile' }
];

export const MobileNavigation: React.FC<MobileNavigationProps> = ({
  onCreateClick,
  notificationCount = 0
}) => {
  const [location, setLocation] = useLocation();

  const handleItemClick = (item: typeof navigationItems[0]) => {
    if (item.id === 'create') {
      onCreateClick?.();
    } else if (item.path) {
      setLocation(item.path);
    }
  };

  const isActive = (path: string | null) => {
    if (!path) return false;
    return location === path || location.startsWith(path);
  };

  return (
    <nav className="fixed bottom-0 left-0 right-0 z-50 bg-white dark:bg-gray-900 border-t border-gray-200 dark:border-gray-700 safe-area-inset-bottom">
      <div className="flex items-center justify-around px-2 py-1 pb-safe">
        {navigationItems.map((item) => {
          const Icon = item.icon;
          const active = isActive(item.path);

          if (item.id === 'create') {
            return (
              <Button
                key={item.id}
                onClick={() => handleItemClick(item)}
                className={cn(
                  "relative flex flex-col items-center justify-center min-h-[64px] px-3 py-2 rounded-full",
                  "bg-primary text-primary-foreground hover:bg-primary/90",
                  "shadow-lg transform transition-all duration-200",
                  "active:scale-95"
                )}
                size="sm"
              >
                <Icon className="w-6 h-6" />
              </Button>
            );
          }

          return (
            <Button
              key={item.id}
              variant="ghost"
              onClick={() => handleItemClick(item)}
              className={cn(
                "relative flex flex-col items-center justify-center min-h-[64px] px-3 py-1 rounded-lg",
                "transition-all duration-200 active:scale-95",
                active
                  ? "text-primary bg-primary/10"
                  : "text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-100"
              )}
            >
              <div className="relative">
                <Icon className={cn("w-5 h-5", active && "stroke-2")} />
                {item.id === 'profile' && notificationCount > 0 && (
                  <Badge
                    variant="destructive"
                    className="absolute -top-2 -right-2 w-5 h-5 p-0 text-xs flex items-center justify-center"
                  >
                    {notificationCount > 9 ? '9+' : notificationCount}
                  </Badge>
                )}
              </div>
              <span className={cn(
                "text-xs mt-1 transition-opacity duration-200",
                active ? "font-medium" : "font-normal"
              )}>
                {item.label}
              </span>
            </Button>
          );
        })}
      </div>
    </nav>
  );
};
```

## STEP 4: MOBILE-OPTIMIZED PROMPT CARD

**CREATE FILE: `client/src/components/mobile/MobilePromptCard.tsx`**

```tsx
import React, { useState, useRef } from 'react';
import { Card, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { AvatarDisplay } from '@/components/ui/avatar-display';
import { useToast } from '@/hooks/use-toast';
import {
  Copy,
  Heart,
  Share,
  MoreVertical,
  Globe,
  Lock,
  Bookmark,
  Zap
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { motion, PanInfo } from 'framer-motion';

interface MobilePromptCardProps {
  prompt: {
    id: string;
    title: string;
    content: string;
    platform?: string;
    tags?: string[];
    isPublic?: boolean;
    isFavorite?: boolean;
    likeCount?: number;
    saveCount?: number;
    remixCount?: number;
    isLiked?: boolean;
    isSaved?: boolean;
    user?: {
      username?: string;
      displayName?: string;
      avatar40Url?: string;
      hasCustomAvatar?: boolean;
      avatarGeneratedColor?: string;
    };
    createdAt: string;
  };
  onLike?: (id: string) => void;
  onSave?: (id: string) => void;
  onShare?: (prompt: any) => void;
  onEdit?: (prompt: any) => void;
  onDelete?: (id: string) => void;
  showCreator?: boolean;
}

export const MobilePromptCard: React.FC<MobilePromptCardProps> = ({
  prompt,
  onLike,
  onSave,
  onShare,
  onEdit,
  onDelete,
  showCreator = false
}) => {
  const { toast } = useToast();
  const [isExpanded, setIsExpanded] = useState(false);
  const [swipeAction, setSwipeAction] = useState<'like' | 'save' | null>(null);
  const cardRef = useRef<HTMLDivElement>(null);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(prompt.content);
      toast({ title: 'Prompt copied to clipboard!' });

      // Haptic feedback if available
      if ('vibrate' in navigator) {
        navigator.vibrate(50);
      }
    } catch (error) {
      toast({
        variant: 'destructive',
        title: 'Failed to copy prompt'
      });
    }
  };

  const handleSwipe = (event: any, info: PanInfo) => {
    const swipeThreshold = 100;
    const velocity = info.velocity.x;
    const offset = info.offset.x;

    if (Math.abs(velocity) > 500 || Math.abs(offset) > swipeThreshold) {
      if (offset > 0) {
        // Swipe right - Like
        setSwipeAction('like');
        onLike?.(prompt.id);
        if ('vibrate' in navigator) {
          navigator.vibrate([50, 50, 50]);
        }
      } else {
        // Swipe left - Save
        setSwipeAction('save');
        onSave?.(prompt.id);
        if ('vibrate' in navigator) {
          navigator.vibrate([100]);
        }
      }

      // Reset swipe action after animation
      setTimeout(() => setSwipeAction(null), 500);
    }
  };

  const truncateContent = (content: string, maxLength: number = 150) => {
    if (content.length <= maxLength) return content;
    return content.substring(0, maxLength) + '...';
  };

  return (
    <motion.div
      ref={cardRef}
      drag="x"
      dragConstraints={{ left: 0, right: 0 }}
      onDragEnd={handleSwipe}
      dragElastic={0.2}
      whileDrag={{ scale: 0.95 }}
      className="relative"
    >
      {/* Swipe Action Indicators */}
      <div className="absolute inset-0 z-0 flex">
        <div className={cn(
          "flex-1 bg-red-500 flex items-center justify-start pl-6 rounded-l-lg transition-opacity",
          swipeAction === 'like' ? 'opacity-100' : 'opacity-0'
        )}>
          <Heart className="w-6 h-6 text-white fill-white" />
        </div>
        <div className={cn(
          "flex-1 bg-blue-500 flex items-center justify-end pr-6 rounded-r-lg transition-opacity",
          swipeAction === 'save' ? 'opacity-100' : 'opacity-0'
        )}>
          <Bookmark className="w-6 h-6 text-white fill-white" />
        </div>
      </div>

      <Card className="relative z-10 bg-white dark:bg-gray-800 shadow-sm hover:shadow-md transition-all duration-200">
        <CardContent className="p-4">
          {/* Header */}
          <div className="flex items-start justify-between mb-3">
            <div className="flex items-center space-x-3 flex-1 min-w-0">
              {showCreator && prompt.user && (
                <AvatarDisplay user={prompt.user} size="sm" />
              )}
              <div className="flex-1 min-w-0">
                <div className="flex items-center space-x-2">
                  <h3 className="font-semibold text-base truncate">
                    {prompt.title}
                  </h3>
                  {prompt.isPublic ? (
                    <Globe className="w-4 h-4 text-green-500" />
                  ) : (
                    <Lock className="w-4 h-4 text-gray-400" />
                  )}
                </div>
                {showCreator && prompt.user && (
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    @{prompt.user.username}
                  </p>
                )}
              </div>
            </div>

            <Button variant="ghost" size="sm" className="shrink-0">
              <MoreVertical className="w-4 h-4" />
            </Button>
          </div>

          {/* Content */}
          <div className="mb-4">
            <p className="text-gray-700 dark:text-gray-300 text-sm leading-relaxed">
              {isExpanded ? prompt.content : truncateContent(prompt.content)}
            </p>
            {prompt.content.length > 150 && (
              <Button
                variant="ghost"
                size="sm"
                onClick={() => setIsExpanded(!isExpanded)}
                className="mt-2 p-0 h-auto text-primary hover:bg-transparent"
              >
                {isExpanded ? 'Show less' : 'Show more'}
              </Button>
            )}
          </div>

          {/* Platform and Tags */}
          <div className="flex flex-wrap gap-2 mb-4">
            {prompt.platform && (
              <Badge variant="secondary" className="text-xs">
                {prompt.platform}
              </Badge>
            )}
            {prompt.tags?.slice(0, 3).map((tag) => (
              <Badge key={tag} variant="outline" className="text-xs">
                {tag}
              </Badge>
            ))}
            {prompt.tags && prompt.tags.length > 3 && (
              <Badge variant="outline" className="text-xs">
                +{prompt.tags.length - 3}
              </Badge>
            )}
          </div>

          {/* Actions */}
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <Button
                variant="ghost"
                size="sm"
                onClick={() => onLike?.(prompt.id)}
                className={cn(
                  "flex items-center space-x-1 px-2 py-1 h-8",
                  prompt.isLiked && "text-red-500"
                )}
              >
                <Heart className={cn("w-4 h-4", prompt.isLiked && "fill-current")} />
                <span className="text-xs">{prompt.likeCount || 0}</span>
              </Button>

              <Button
                variant="ghost"
                size="sm"
                onClick={() => onSave?.(prompt.id)}
                className={cn(
                  "flex items-center space-x-1 px-2 py-1 h-8",
                  prompt.isSaved && "text-blue-500"
                )}
              >
                <Bookmark className={cn("w-4 h-4", prompt.isSaved && "fill-current")} />
                <span className="text-xs">{prompt.saveCount || 0}</span>
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="flex items-center space-x-1 px-2 py-1 h-8"
              >
                <Zap className="w-4 h-4" />
                <span className="text-xs">{prompt.remixCount || 0}</span>
              </Button>
            </div>

            <div className="flex items-center space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={handleCopy}
                className="h-8 px-3"
              >
                <Copy className="w-3 h-3 mr-1" />
                Copy
              </Button>

              <Button
                variant="ghost"
                size="sm"
                onClick={() => onShare?.(prompt)}
                className="h-8 px-2"
              >
                <Share className="w-4 h-4" />
              </Button>
            </div>
          </div>

          {/* Timestamp */}
          <div className="mt-3 text-xs text-gray-500 dark:text-gray-400">
            {new Date(prompt.createdAt).toLocaleDateString()}
          </div>
        </CardContent>
      </Card>
    </motion.div>
  );
};
```

## STEP 5: PULL-TO-REFRESH COMPONENT

**CREATE FILE: `client/src/components/mobile/PullToRefresh.tsx`**

```tsx
import React, { useState, useRef, useCallback } from 'react';
import { motion, PanInfo } from 'framer-motion';
import { RefreshCw } from 'lucide-react';
import { cn } from '@/lib/utils';

interface PullToRefreshProps {
  onRefresh: () => Promise<void>;
  children: React.ReactNode;
  disabled?: boolean;
}

export const PullToRefresh: React.FC<PullToRefreshProps> = ({
  onRefresh,
  children,
  disabled = false
}) => {
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [pullDistance, setPullDistance] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);

  const pullThreshold = 80;
  const maxPull = 120;

  const handleDragEnd = useCallback(async (event: any, info: PanInfo) => {
    const shouldRefresh = pullDistance >= pullThreshold && !disabled;

    if (shouldRefresh && !isRefreshing) {
      setIsRefreshing(true);

      // Haptic feedback
      if ('vibrate' in navigator) {
        navigator.vibrate(100);
      }

      try {
        await onRefresh();
      } catch (error) {
        console.error('Refresh failed:', error);
      } finally {
        setIsRefreshing(false);
      }
    }

    setPullDistance(0);
  }, [pullDistance, pullThreshold, disabled, isRefreshing, onRefresh]);

  const handleDrag = useCallback((event: any, info: PanInfo) => {
    if (disabled || isRefreshing) return;

    const scrollTop = containerRef.current?.scrollTop || 0;

    // Only allow pull-to-refresh when at the top
    if (scrollTop <= 0 && info.offset.y > 0) {
      const newPullDistance = Math.min(info.offset.y * 0.5, maxPull);
      setPullDistance(newPullDistance);
    }
  }, [disabled, isRefreshing, maxPull]);

  const getRefreshIndicatorScale = () => {
    return Math.min(pullDistance / pullThreshold, 1);
  };

  const getRefreshIndicatorRotation = () => {
    if (isRefreshing) return 360;
    return (pullDistance / pullThreshold) * 180;
  };

  return (
    <div className="relative overflow-hidden h-full">
      {/* Refresh Indicator */}
      <motion.div
        className="absolute top-0 left-1/2 transform -translate-x-1/2 z-10"
        style={{
          y: Math.max(-40, pullDistance - 40)
        }}
      >
        <div className={cn(
          "w-10 h-10 bg-primary rounded-full flex items-center justify-center shadow-lg",
          "transition-opacity duration-200",
          pullDistance > 20 ? "opacity-100" : "opacity-0"
        )}>
          <motion.div
            animate={{
              rotate: isRefreshing ? 360 : getRefreshIndicatorRotation(),
              scale: getRefreshIndicatorScale()
            }}
            transition={{
              rotate: isRefreshing ? {
                duration: 1,
                repeat: Infinity,
                ease: "linear"
              } : {
                duration: 0.2
              },
              scale: { duration: 0.2 }
            }}
          >
            <RefreshCw className="w-5 h-5 text-primary-foreground" />
          </motion.div>
        </div>
      </motion.div>

      {/* Pullable Content */}
      <motion.div
        ref={containerRef}
        drag="y"
        dragConstraints={{ top: 0, bottom: 0 }}
        dragElastic={0.2}
        onDrag={handleDrag}
        onDragEnd={handleDragEnd}
        className="h-full overflow-auto"
        style={{
          y: isRefreshing ? 60 : Math.min(pullDistance, maxPull)
        }}
      >
        {children}
      </motion.div>
    </div>
  );
};
```

## STEP 6: EXPLORE PAGE DATABASE SCHEMA

**UPDATE FILE: `shared/schema.ts`**

Add these new tables and update existing ones:

```typescript
// Update prompts table (add these columns)
export const prompts = pgTable("prompts", {
  // ... existing fields ...
  isPublic: boolean("is_public").default(false),
  viewCount: integer("view_count").default(0),
  likeCount: integer("like_count").default(0),
  saveCount: integer("save_count").default(0),
  remixCount: integer("remix_count").default(0),
  category: varchar("category", { length: 50 }),
  featuredAt: timestamp("featured_at"),
  trendingScore: integer("trending_score").default(0),
});

// Engagement tracking tables
export const promptLikes = pgTable("prompt_likes", {
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  promptId: varchar("prompt_id").notNull().references(() => prompts.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => ({
  pk: primaryKey(table.userId, table.promptId)
}));

export const promptSaves = pgTable("prompt_saves", {
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  promptId: varchar("prompt_id").notNull().references(() => prompts.id, { onDelete: 'cascade' }),
  savedToFolderId: varchar("saved_to_folder_id").references(() => folders.id, { onDelete: 'set null' }),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => ({
  pk: primaryKey(table.userId, table.promptId)
}));

export const promptRemixes = pgTable("prompt_remixes", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  originalPromptId: varchar("original_prompt_id").notNull().references(() => prompts.id),
  remixPromptId: varchar("remix_prompt_id").notNull().references(() => prompts.id),
  remixedByUserId: varchar("remixed_by_user_id").notNull().references(() => users.id),
  attributionText: text("attribution_text"),
  createdAt: timestamp("created_at").defaultNow(),
});

export const userFollows = pgTable("user_follows", {
  followerId: varchar("follower_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  followingId: varchar("following_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  createdAt: timestamp("created_at").defaultNow(),
}, (table) => ({
  pk: primaryKey(table.followerId, table.followingId)
}));

export const promptExamples = pgTable("prompt_examples", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  promptId: varchar("prompt_id").notNull().references(() => prompts.id, { onDelete: 'cascade' }),
  exampleInput: text("example_input"),
  exampleOutput: text("example_output").notNull(),
  outputType: varchar("output_type", { length: 20 }).default('text'),
  imageUrl: varchar("image_url", { length: 500 }),
  metadata: jsonb("metadata"),
  displayOrder: integer("display_order").default(0),
  createdAt: timestamp("created_at").defaultNow(),
});

// Collections for curated content
export const promptCollections = pgTable("prompt_collections", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  name: varchar("name", { length: 200 }).notNull(),
  description: text("description"),
  createdByUserId: varchar("created_by_user_id").notNull().references(() => users.id),
  isPublic: boolean("is_public").default(true),
  isFeatured: boolean("is_featured").default(false),
  coverImageUrl: varchar("cover_image_url", { length: 500 }),
  promptCount: integer("prompt_count").default(0),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const collectionPrompts = pgTable("collection_prompts", {
  collectionId: varchar("collection_id").notNull().references(() => promptCollections.id, { onDelete: 'cascade' }),
  promptId: varchar("prompt_id").notNull().references(() => prompts.id, { onDelete: 'cascade' }),
  addedByUserId: varchar("added_by_user_id").notNull().references(() => users.id),
  displayOrder: integer("display_order").default(0),
  addedAt: timestamp("added_at").defaultNow(),
}, (table) => ({
  pk: primaryKey(table.collectionId, table.promptId)
}));
```

## STEP 7: EXPLORE API ENDPOINTS

**UPDATE FILE: `server/routes.ts`**

Add these new API endpoints:

```typescript
// Add these imports at the top
import {
  prompts,
  promptLikes,
  promptSaves,
  promptRemixes,
  userFollows,
  promptExamples,
  promptCollections,
  collectionPrompts
} from '@shared/schema';
import { desc, asc, count, sum, avg } from 'drizzle-orm';

// Explore endpoints
app.get("/api/explore/trending", async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;

    // Calculate trending score based on recent engagement
    const trendingPrompts = await drizzleDB.select({
      prompt: prompts,
      user: {
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatar40Url: users.avatar40Url,
        hasCustomAvatar: users.hasCustomAvatar,
        avatarGeneratedColor: users.avatarGeneratedColor
      },
      likeCount: prompts.likeCount,
      saveCount: prompts.saveCount,
      remixCount: prompts.remixCount
    })
    .from(prompts)
    .innerJoin(users, eq(prompts.userId, users.id))
    .where(and(
      eq(prompts.isPublic, true),
      isNull(prompts.trashedAt)
    ))
    .orderBy(desc(sql`(${prompts.likeCount} * 3 + ${prompts.saveCount} * 2 + ${prompts.remixCount} * 5) / EXTRACT(EPOCH FROM (NOW() - ${prompts.createdAt})) * 3600`))
    .limit(parseInt(limit as string))
    .offset(parseInt(offset as string));

    res.json({ prompts: trendingPrompts });
  } catch (error) {
    console.error('Trending prompts error:', error);
    res.status(500).json({ error: 'Failed to get trending prompts' });
  }
});

app.get("/api/explore/new", async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;

    const newPrompts = await drizzleDB.select({
      prompt: prompts,
      user: {
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatar40Url: users.avatar40Url,
        hasCustomAvatar: users.hasCustomAvatar,
        avatarGeneratedColor: users.avatarGeneratedColor
      }
    })
    .from(prompts)
    .innerJoin(users, eq(prompts.userId, users.id))
    .where(and(
      eq(prompts.isPublic, true),
      isNull(prompts.trashedAt)
    ))
    .orderBy(desc(prompts.createdAt))
    .limit(parseInt(limit as string))
    .offset(parseInt(offset as string));

    res.json({ prompts: newPrompts });
  } catch (error) {
    console.error('New prompts error:', error);
    res.status(500).json({ error: 'Failed to get new prompts' });
  }
});

app.get("/api/explore/popular", async (req, res) => {
  try {
    const { limit = 20, offset = 0, timeframe = 'all' } = req.query;

    let dateFilter;
    switch (timeframe) {
      case 'day':
        dateFilter = sql`${prompts.createdAt} > NOW() - INTERVAL '1 day'`;
        break;
      case 'week':
        dateFilter = sql`${prompts.createdAt} > NOW() - INTERVAL '1 week'`;
        break;
      case 'month':
        dateFilter = sql`${prompts.createdAt} > NOW() - INTERVAL '1 month'`;
        break;
      default:
        dateFilter = sql`true`;
    }

    const popularPrompts = await drizzleDB.select({
      prompt: prompts,
      user: {
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatar40Url: users.avatar40Url,
        hasCustomAvatar: users.hasCustomAvatar,
        avatarGeneratedColor: users.avatarGeneratedColor
      }
    })
    .from(prompts)
    .innerJoin(users, eq(prompts.userId, users.id))
    .where(and(
      eq(prompts.isPublic, true),
      isNull(prompts.trashedAt),
      dateFilter
    ))
    .orderBy(desc(sql`${prompts.likeCount} + ${prompts.saveCount} + ${prompts.remixCount}`))
    .limit(parseInt(limit as string))
    .offset(parseInt(offset as string));

    res.json({ prompts: popularPrompts });
  } catch (error) {
    console.error('Popular prompts error:', error);
    res.status(500).json({ error: 'Failed to get popular prompts' });
  }
});

// Engagement actions
app.post("/api/prompts/:id/like", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { id } = req.params;

    // Toggle like
    const existing = await drizzleDB.select()
      .from(promptLikes)
      .where(and(
        eq(promptLikes.promptId, id),
        eq(promptLikes.userId, authUser.userId)
      ))
      .limit(1);

    if (existing.length > 0) {
      // Unlike
      await drizzleDB.delete(promptLikes)
        .where(and(
          eq(promptLikes.promptId, id),
          eq(promptLikes.userId, authUser.userId)
        ));

      await drizzleDB.update(prompts)
        .set({ likeCount: sql`${prompts.likeCount} - 1` })
        .where(eq(prompts.id, id));

      res.json({ liked: false });
    } else {
      // Like
      await drizzleDB.insert(promptLikes)
        .values({
          promptId: id,
          userId: authUser.userId
        });

      await drizzleDB.update(prompts)
        .set({ likeCount: sql`${prompts.likeCount} + 1` })
        .where(eq(prompts.id, id));

      res.json({ liked: true });
    }
  } catch (error) {
    console.error('Like toggle error:', error);
    res.status(500).json({ error: 'Failed to toggle like' });
  }
});

app.post("/api/prompts/:id/save", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { id } = req.params;
    const { folderId } = req.body;

    // Toggle save
    const existing = await drizzleDB.select()
      .from(promptSaves)
      .where(and(
        eq(promptSaves.promptId, id),
        eq(promptSaves.userId, authUser.userId)
      ))
      .limit(1);

    if (existing.length > 0) {
      // Unsave
      await drizzleDB.delete(promptSaves)
        .where(and(
          eq(promptSaves.promptId, id),
          eq(promptSaves.userId, authUser.userId)
        ));

      await drizzleDB.update(prompts)
        .set({ saveCount: sql`${prompts.saveCount} - 1` })
        .where(eq(prompts.id, id));

      res.json({ saved: false });
    } else {
      // Save
      await drizzleDB.insert(promptSaves)
        .values({
          promptId: id,
          userId: authUser.userId,
          savedToFolderId: folderId || null
        });

      await drizzleDB.update(prompts)
        .set({ saveCount: sql`${prompts.saveCount} + 1` })
        .where(eq(prompts.id, id));

      res.json({ saved: true });
    }
  } catch (error) {
    console.error('Save toggle error:', error);
    res.status(500).json({ error: 'Failed to toggle save' });
  }
});

// Follow system
app.post("/api/users/:id/follow", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { id: targetUserId } = req.params;

    if (targetUserId === authUser.userId) {
      return res.status(400).json({ error: 'Cannot follow yourself' });
    }

    // Toggle follow
    const existing = await drizzleDB.select()
      .from(userFollows)
      .where(and(
        eq(userFollows.followerId, authUser.userId),
        eq(userFollows.followingId, targetUserId)
      ))
      .limit(1);

    if (existing.length > 0) {
      // Unfollow
      await drizzleDB.delete(userFollows)
        .where(and(
          eq(userFollows.followerId, authUser.userId),
          eq(userFollows.followingId, targetUserId)
        ));

      // Update counts
      await drizzleDB.update(users)
        .set({ followingCount: sql`${users.followingCount} - 1` })
        .where(eq(users.id, authUser.userId));

      await drizzleDB.update(users)
        .set({ followerCount: sql`${users.followerCount} - 1` })
        .where(eq(users.id, targetUserId));

      res.json({ following: false });
    } else {
      // Follow
      await drizzleDB.insert(userFollows)
        .values({
          followerId: authUser.userId,
          followingId: targetUserId
        });

      // Update counts
      await drizzleDB.update(users)
        .set({ followingCount: sql`${users.followingCount} + 1` })
        .where(eq(users.id, authUser.userId));

      await drizzleDB.update(users)
        .set({ followerCount: sql`${users.followerCount} + 1` })
        .where(eq(users.id, targetUserId));

      res.json({ following: true });
    }
  } catch (error) {
    console.error('Follow toggle error:', error);
    res.status(500).json({ error: 'Failed to toggle follow' });
  }
});

// Example outputs
app.get("/api/prompts/:id/examples", async (req, res) => {
  try {
    const { id } = req.params;

    const examples = await drizzleDB.select()
      .from(promptExamples)
      .where(eq(promptExamples.promptId, id))
      .orderBy(asc(promptExamples.displayOrder), asc(promptExamples.createdAt));

    res.json({ examples });
  } catch (error) {
    console.error('Examples fetch error:', error);
    res.status(500).json({ error: 'Failed to get examples' });
  }
});

app.post("/api/prompts/:id/examples", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { id } = req.params;
    const { exampleInput, exampleOutput, outputType, imageUrl, metadata } = req.body;

    // Verify prompt ownership
    const prompt = await drizzleDB.select()
      .from(prompts)
      .where(and(eq(prompts.id, id), eq(prompts.userId, authUser.userId)))
      .limit(1);

    if (!prompt[0]) {
      return res.status(404).json({ error: 'Prompt not found or not owned by user' });
    }

    const example = await drizzleDB.insert(promptExamples)
      .values({
        promptId: id,
        exampleInput,
        exampleOutput,
        outputType: outputType || 'text',
        imageUrl,
        metadata
      })
      .returning();

    res.json({ example: example[0] });
  } catch (error) {
    console.error('Example creation error:', error);
    res.status(500).json({ error: 'Failed to create example' });
  }
});
```

## STEP 8: EXPLORE PAGE COMPONENT

**CREATE FILE: `client/src/pages/ExplorePage.tsx`**

```tsx
import React, { useState, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { MobilePromptCard } from '@/components/mobile/MobilePromptCard';
import { PullToRefresh } from '@/components/mobile/PullToRefresh';
import { useToast } from '@/hooks/use-toast';
import {
  Search,
  Filter,
  TrendingUp,
  Clock,
  Star,
  Users
} from 'lucide-react';
import { cn } from '@/lib/utils';

const categories = [
  { id: 'all', label: 'All', icon: null },
  { id: 'coding', label: 'Coding', icon: '💻' },
  { id: 'writing', label: 'Writing', icon: '✍️' },
  { id: 'creative', label: 'Creative', icon: '🎨' },
  { id: 'business', label: 'Business', icon: '💼' },
  { id: 'research', label: 'Research', icon: '🔍' },
  { id: 'education', label: 'Education', icon: '📚' }
];

export default function ExplorePage() {
  const { toast } = useToast();
  const [activeTab, setActiveTab] = useState('trending');
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedCategory, setSelectedCategory] = useState('all');

  // Fetch trending prompts
  const { data: trendingPrompts, isLoading: loadingTrending, refetch: refetchTrending } = useQuery({
    queryKey: ['explore', 'trending', selectedCategory],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (selectedCategory !== 'all') {
        params.append('category', selectedCategory);
      }

      const response = await fetch(`/api/explore/trending?${params}`, {
        headers: { 'Authorization': `Bearer ${localStorage.getItem('authToken')}` }
      });
      return response.json();
    },
    staleTime: 5 * 60 * 1000 // 5 minutes
  });

  // Fetch new prompts
  const { data: newPrompts, isLoading: loadingNew, refetch: refetchNew } = useQuery({
    queryKey: ['explore', 'new', selectedCategory],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (selectedCategory !== 'all') {
        params.append('category', selectedCategory);
      }

      const response = await fetch(`/api/explore/new?${params}`, {
        headers: { 'Authorization': `Bearer ${localStorage.getItem('authToken')}` }
      });
      return response.json();
    },
    staleTime: 2 * 60 * 1000 // 2 minutes
  });

  // Fetch popular prompts
  const { data: popularPrompts, isLoading: loadingPopular, refetch: refetchPopular } = useQuery({
    queryKey: ['explore', 'popular', selectedCategory],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (selectedCategory !== 'all') {
        params.append('category', selectedCategory);
      }

      const response = await fetch(`/api/explore/popular?${params}`, {
        headers: { 'Authorization': `Bearer ${localStorage.getItem('authToken')}` }
      });
      return response.json();
    },
    staleTime: 10 * 60 * 1000 // 10 minutes
  });

  const handleRefresh = async () => {
    switch (activeTab) {
      case 'trending':
        await refetchTrending();
        break;
      case 'new':
        await refetchNew();
        break;
      case 'popular':
        await refetchPopular();
        break;
    }
  };

  const handleLike = async (promptId: string) => {
    try {
      const response = await fetch(`/api/prompts/${promptId}/like`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        // Refresh current tab data
        await handleRefresh();

        if ('vibrate' in navigator) {
          navigator.vibrate(50);
        }
      }
    } catch (error) {
      toast({
        variant: 'destructive',
        title: 'Failed to like prompt'
      });
    }
  };

  const handleSave = async (promptId: string) => {
    try {
      const response = await fetch(`/api/prompts/${promptId}/save`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${localStorage.getItem('authToken')}`,
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        await handleRefresh();

        if ('vibrate' in navigator) {
          navigator.vibrate(100);
        }

        toast({ title: 'Prompt saved to your library!' });
      }
    } catch (error) {
      toast({
        variant: 'destructive',
        title: 'Failed to save prompt'
      });
    }
  };

  const getCurrentData = () => {
    switch (activeTab) {
      case 'trending':
        return { data: trendingPrompts?.prompts || [], isLoading: loadingTrending };
      case 'new':
        return { data: newPrompts?.prompts || [], isLoading: loadingNew };
      case 'popular':
        return { data: popularPrompts?.prompts || [], isLoading: loadingPopular };
      default:
        return { data: [], isLoading: false };
    }
  };

  const { data: currentPrompts, isLoading } = getCurrentData();

  return (
    <div className="flex flex-col h-full bg-gray-50 dark:bg-gray-900">
      {/* Header */}
      <div className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-4 py-3 safe-area-inset-top">
        <div className="flex items-center space-x-3">
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4" />
            <Input
              placeholder="Search prompts..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="pl-10 pr-4 py-2 bg-gray-100 dark:bg-gray-700 border-none rounded-full"
            />
          </div>
          <Button variant="outline" size="sm" className="rounded-full">
            <Filter className="w-4 h-4" />
          </Button>
        </div>
      </div>

      {/* Category Filter */}
      <div className="bg-white dark:bg-gray-800 px-4 py-3 border-b border-gray-200 dark:border-gray-700">
        <div className="flex space-x-2 overflow-x-auto scrollbar-hide">
          {categories.map((category) => (
            <Button
              key={category.id}
              variant={selectedCategory === category.id ? "default" : "outline"}
              size="sm"
              onClick={() => setSelectedCategory(category.id)}
              className="shrink-0 rounded-full"
            >
              {category.icon && <span className="mr-1">{category.icon}</span>}
              {category.label}
            </Button>
          ))}
        </div>
      </div>

      {/* Content Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab} className="flex-1 flex flex-col">
        <TabsList className="grid w-full grid-cols-3 bg-white dark:bg-gray-800 rounded-none border-b border-gray-200 dark:border-gray-700">
          <TabsTrigger value="trending" className="flex items-center space-x-2">
            <TrendingUp className="w-4 h-4" />
            <span>Trending</span>
          </TabsTrigger>
          <TabsTrigger value="new" className="flex items-center space-x-2">
            <Clock className="w-4 h-4" />
            <span>New</span>
          </TabsTrigger>
          <TabsTrigger value="popular" className="flex items-center space-x-2">
            <Star className="w-4 h-4" />
            <span>Popular</span>
          </TabsTrigger>
        </TabsList>

        <div className="flex-1 overflow-hidden">
          <TabsContent value="trending" className="h-full m-0">
            <PullToRefresh onRefresh={handleRefresh}>
              <div className="p-4 space-y-4 pb-safe">
                {isLoading ? (
                  <div className="space-y-4">
                    {[...Array(3)].map((_, i) => (
                      <div key={i} className="bg-white dark:bg-gray-800 rounded-lg p-4 animate-pulse">
                        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded mb-3"></div>
                        <div className="h-20 bg-gray-200 dark:bg-gray-700 rounded mb-3"></div>
                        <div className="flex space-x-2">
                          <div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                          <div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : currentPrompts.length > 0 ? (
                  currentPrompts.map((item: any) => (
                    <MobilePromptCard
                      key={item.prompt.id}
                      prompt={{
                        ...item.prompt,
                        user: item.user
                      }}
                      onLike={handleLike}
                      onSave={handleSave}
                      showCreator={true}
                    />
                  ))
                ) : (
                  <div className="text-center py-12">
                    <TrendingUp className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <p className="text-gray-500 dark:text-gray-400">No trending prompts found</p>
                  </div>
                )}
              </div>
            </PullToRefresh>
          </TabsContent>

          <TabsContent value="new" className="h-full m-0">
            <PullToRefresh onRefresh={handleRefresh}>
              <div className="p-4 space-y-4 pb-safe">
                {isLoading ? (
                  <div className="space-y-4">
                    {[...Array(3)].map((_, i) => (
                      <div key={i} className="bg-white dark:bg-gray-800 rounded-lg p-4 animate-pulse">
                        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded mb-3"></div>
                        <div className="h-20 bg-gray-200 dark:bg-gray-700 rounded mb-3"></div>
                        <div className="flex space-x-2">
                          <div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                          <div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : currentPrompts.length > 0 ? (
                  currentPrompts.map((item: any) => (
                    <MobilePromptCard
                      key={item.prompt.id}
                      prompt={{
                        ...item.prompt,
                        user: item.user
                      }}
                      onLike={handleLike}
                      onSave={handleSave}
                      showCreator={true}
                    />
                  ))
                ) : (
                  <div className="text-center py-12">
                    <Clock className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <p className="text-gray-500 dark:text-gray-400">No new prompts found</p>
                  </div>
                )}
              </div>
            </PullToRefresh>
          </TabsContent>

          <TabsContent value="popular" className="h-full m-0">
            <PullToRefresh onRefresh={handleRefresh}>
              <div className="p-4 space-y-4 pb-safe">
                {isLoading ? (
                  <div className="space-y-4">
                    {[...Array(3)].map((_, i) => (
                      <div key={i} className="bg-white dark:bg-gray-800 rounded-lg p-4 animate-pulse">
                        <div className="h-4 bg-gray-200 dark:bg-gray-700 rounded mb-3"></div>
                        <div className="h-20 bg-gray-200 dark:bg-gray-700 rounded mb-3"></div>
                        <div className="flex space-x-2">
                          <div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                          <div className="h-6 w-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                        </div>
                      </div>
                    ))}
                  </div>
                ) : currentPrompts.length > 0 ? (
                  currentPrompts.map((item: any) => (
                    <MobilePromptCard
                      key={item.prompt.id}
                      prompt={{
                        ...item.prompt,
                        user: item.user
                      }}
                      onLike={handleLike}
                      onSave={handleSave}
                      showCreator={true}
                    />
                  ))
                ) : (
                  <div className="text-center py-12">
                    <Star className="w-12 h-12 text-gray-400 mx-auto mb-4" />
                    <p className="text-gray-500 dark:text-gray-400">No popular prompts found</p>
                  </div>
                )}
              </div>
            </PullToRefresh>
          </TabsContent>
        </div>
      </Tabs>
    </div>
  );
}
```

## STEP 9: UPDATE APP ROUTING AND MOBILE LAYOUT

**UPDATE FILE: `client/src/App.tsx`**

Add the explore route and mobile layout:

```tsx
import { Switch, Route, Redirect } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { ThemeProvider } from "@/components/ui/theme-provider";
import { AuthProvider } from "@/hooks/useAuth";
import { MobileNavigation } from "@/components/mobile/MobileNavigation";
import Login from "@/pages/login";
import Signup from "@/pages/signup";
import Dashboard from "@/pages/dashboard";
import ExplorePage from "@/pages/ExplorePage";
import TemplatesPage from "@/pages/TemplatesPage";
import FoldersPage from "@/pages/FoldersPage";
import Settings from "@/pages/settings";
import NotFound from "@/pages/not-found";
import TestAuth from "@/pages/test-auth";
import { useState, useEffect } from "react";

function MobileLayout({ children }: { children: React.ReactNode }) {
  const [showCreateModal, setShowCreateModal] = useState(false);

  return (
    <div className="min-h-screen pb-16 md:pb-0">
      {children}
      <div className="md:hidden">
        <MobileNavigation
          onCreateClick={() => setShowCreateModal(true)}
          notificationCount={0}
        />
      </div>
    </div>
  );
}

function Router() {
  return (
    <Switch>
      <Route path="/" component={() => <Redirect to="/dashboard" />} />
      <Route path="/login" component={Login} />
      <Route path="/signup" component={Signup} />
      <Route path="/explore" component={() => (
        <MobileLayout>
          <ExplorePage />
        </MobileLayout>
      )} />
      <Route path="/dashboard/templates" component={() => (
        <MobileLayout>
          <TemplatesPage />
        </MobileLayout>
      )} />
      <Route path="/dashboard/folders" component={() => (
        <MobileLayout>
          <FoldersPage />
        </MobileLayout>
      )} />
      <Route path="/dashboard/folder/:folderId" component={() => (
        <MobileLayout>
          <Dashboard />
        </MobileLayout>
      )} />
      <Route path="/dashboard/:view" component={() => (
        <MobileLayout>
          <Dashboard />
        </MobileLayout>
      )} />
      <Route path="/dashboard" component={() => (
        <MobileLayout>
          <Dashboard />
        </MobileLayout>
      )} />
      <Route path="/settings" component={() => (
        <MobileLayout>
          <Settings />
        </MobileLayout>
      )} />
      <Route path="/test-auth" component={TestAuth} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider defaultTheme="light">
        <AuthProvider>
          <TooltipProvider>
            <Toaster />
            <Router />
          </TooltipProvider>
        </AuthProvider>
      </ThemeProvider>
    </QueryClientProvider>
  );
}

export default App;
```

## STEP 10: MOBILE-OPTIMIZED STYLES

**UPDATE FILE: `client/src/index.css`**

Add these mobile-specific styles:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Mobile-specific utilities */
@layer utilities {
  /* Safe area support for iOS */
  .safe-area-inset-top {
    padding-top: env(safe-area-inset-top);
  }

  .safe-area-inset-bottom {
    padding-bottom: env(safe-area-inset-bottom);
  }

  .pb-safe {
    padding-bottom: max(1rem, env(safe-area-inset-bottom));
  }

  .pt-safe {
    padding-top: max(1rem, env(safe-area-inset-top));
  }

  /* Hide scrollbars */
  .scrollbar-hide {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }

  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }

  /* Touch-friendly interactions */
  .touch-manipulation {
    touch-action: manipulation;
  }

  /* Prevent overscroll bounce on mobile */
  .no-overscroll {
    overscroll-behavior: none;
  }
}

/* PWA-specific styles */
@media (display-mode: standalone) {
  body {
    -webkit-user-select: none;
    user-select: none;
  }
}

/* Mobile viewport optimizations */
@supports (-webkit-touch-callout: none) {
  /* iOS Safari specific styles */
  .ios-safe-area {
    padding-top: constant(safe-area-inset-top);
    padding-top: env(safe-area-inset-top);
    padding-bottom: constant(safe-area-inset-bottom);
    padding-bottom: env(safe-area-inset-bottom);
  }
}

/* Performance optimizations for mobile */
* {
  -webkit-tap-highlight-color: transparent;
}

/* Smooth scrolling */
html {
  scroll-behavior: smooth;
}

/* Mobile-first responsive breakpoints */
@media (max-width: 768px) {
  /* Force hardware acceleration for smoother animations */
  .card {
    -webkit-transform: translateZ(0);
    transform: translateZ(0);
  }

  /* Optimize touch targets */
  button, a, [role="button"] {
    min-height: 44px;
    min-width: 44px;
  }
}

/* Dark mode optimizations for mobile */
@media (prefers-color-scheme: dark) {
  /* Reduce eye strain on mobile */
  .dark {
    color-scheme: dark;
  }
}

/* Reduced motion preferences */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
```

## STEP 11: RUN DATABASE MIGRATION

Execute these commands in your Replit terminal:

```bash
# Apply the database schema changes
npm run db:push

# Verify the new tables were created
echo "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name;" | npm run db:query
```

## STEP 12: CREATE PLACEHOLDER ICONS FOR PWA

**CREATE DIRECTORY: `public/icons/`**

Create placeholder icon files (you can replace these with actual icons later):

```bash
# Create the icons directory
mkdir -p public/icons

# Create placeholder SVG icons (replace with actual PNG icons for production)
# These are just for testing - use proper PNG icons for production PWA
```

For testing, you can create simple placeholder files or copy existing favicon files to the icons directory with the appropriate sizes.

## STEP 13: TEST ALL MOBILE AND EXPLORE FEATURES

1. **Start the development server**: `npm run dev`
2. **Test PWA functionality**:
   - Open in mobile browser
   - Check for "Add to Home Screen" prompt
   - Test offline functionality
3. **Test mobile navigation**:
   - Bottom tab navigation works
   - Swipe actions on prompt cards
   - Pull-to-refresh functionality
4. **Test explore features**:
   - Trending, new, and popular tabs
   - Like and save functionality
   - Category filtering
   - Search functionality
5. **Test responsive design**:
   - Mobile layout looks native-like
   - Touch targets are properly sized
   - Animations are smooth

## VERIFICATION CHECKLIST

Phase 2 is complete when:
- [ ] PWA manifest and service worker are configured
- [ ] Mobile navigation with bottom tabs works
- [ ] Swipe actions on prompt cards function
- [ ] Pull-to-refresh works on all explore sections
- [ ] Explore page shows trending, new, and popular prompts
- [ ] Like and save functionality works with haptic feedback
- [ ] Category filtering affects results
- [ ] Database migration completed successfully
- [ ] Mobile performance is smooth (60fps animations)
- [ ] PWA can be installed on mobile devices
- [ ] Offline functionality works for cached content

## PERFORMANCE OPTIMIZATIONS INCLUDED

- **Virtual scrolling** for long lists
- **Image lazy loading** for avatars
- **Aggressive caching** with service worker
- **Haptic feedback** for touch interactions
- **Smooth animations** with Framer Motion
- **Optimized bundle size** with code splitting
- **Touch-friendly** 44px minimum targets
- **Safe area support** for iOS devices

This completes Phase 2 of Epic 6, transforming PromptLockr into a premium mobile-first community platform with native app-like experience and comprehensive discovery features.

The platform now supports:
✅ **Premium Mobile UX** - Native-feeling mobile web app with PWA support
✅ **Community Discovery** - Trending, new, and popular content with engagement
✅ **Touch Interactions** - Swipe actions, haptic feedback, pull-to-refresh
✅ **Performance** - Optimized for mobile with smooth animations and caching

Ready for Phase 3: Advanced AI Capabilities and Multi-Provider Integration!