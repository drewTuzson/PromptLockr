# REPLIT: Implement PromptLockr Epic 6 Phase 1 - Direct Implementation Instructions

## IMMEDIATE ACTIONS REQUIRED

You are implementing Phase 1 of Epic 6 for PromptLockr. This adds username system, profile images, and sharing functionality to an existing React + TypeScript + PostgreSQL application.

**CRITICAL**: Follow these instructions sequentially. Do not ask questions - implement exactly as specified.

## PROJECT STRUCTURE CONTEXT

```
Current PromptLockr Architecture:
├── client/src/
│   ├── components/ui/          # 48 Radix UI components
│   ├── components/dashboard/   # Prompt management components
│   ├── hooks/                  # Custom React hooks
│   ├── pages/                  # Route components
│   └── lib/                    # Utilities
├── server/
│   ├── index.ts               # Express server
│   ├── routes.ts              # API routes
│   ├── db.ts                  # Database connection
│   └── services/              # Business logic
├── shared/
│   ├── schema.ts              # Drizzle ORM schemas
│   └── types/                 # Shared TypeScript types
```

Tech Stack: React 18.3.1, TypeScript, Vite, PostgreSQL, Drizzle ORM, Express.js, Radix UI, TanStack React Query

## STEP 1: DATABASE SCHEMA UPDATES

**FILE: `shared/schema.ts`**

Add these imports and schema updates:

```typescript
// Add to existing imports
import { sql, relations } from "drizzle-orm";
import { pgTable, text, varchar, boolean, timestamp, integer, pgEnum, inet, jsonb } from "drizzle-orm/pg-core";

// Update users table by adding these fields to the existing users schema
export const users = pgTable("users", {
  // ... existing fields ...
  username: varchar("username", { length: 50 }).unique(),
  displayName: varchar("display_name", { length: 100 }),
  bio: text("bio"),
  avatarUrl: varchar("avatar_url", { length: 500 }),
  avatar40Url: varchar("avatar_40_url", { length: 500 }),
  avatar80Url: varchar("avatar_80_url", { length: 500 }),
  avatar160Url: varchar("avatar_160_url", { length: 500 }),
  avatar320Url: varchar("avatar_320_url", { length: 500 }),
  hasCustomAvatar: boolean("has_custom_avatar").default(false),
  avatarGeneratedColor: varchar("avatar_generated_color", { length: 7 }),
  isVerified: boolean("is_verified").default(false),
  followerCount: integer("follower_count").default(0),
  followingCount: integer("following_count").default(0),
  createdUsernameAt: timestamp("created_username_at"),
  avatarUpdatedAt: timestamp("avatar_updated_at"),
});

// Add to existing prompts table
export const prompts = pgTable("prompts", {
  // ... existing fields ...
  isPublic: boolean("is_public").default(false),
  viewCount: integer("view_count").default(0),
  likeCount: integer("like_count").default(0),
  saveCount: integer("save_count").default(0),
  remixCount: integer("remix_count").default(0),
});

// Add new tables
export const profileImages = pgTable("profile_images", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  originalFilename: varchar("original_filename", { length: 255 }),
  fileSize: integer("file_size"),
  mimeType: varchar("mime_type", { length: 50 }),
  uploadUrl: varchar("upload_url", { length: 500 }),
  processedUrls: jsonb("processed_urls"),
  processingStatus: varchar("processing_status", { length: 20 }).default('pending'),
  uploadIp: inet("upload_ip"),
  createdAt: timestamp("created_at").defaultNow(),
  processedAt: timestamp("processed_at"),
});

export const promptShares = pgTable("prompt_shares", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  promptId: varchar("prompt_id").notNull().references(() => prompts.id, { onDelete: 'cascade' }),
  sharedByUserId: varchar("shared_by_user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  sharedWithUserId: varchar("shared_with_user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  permission: varchar("permission", { length: 20 }).default('view'),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow(),
  accessedAt: timestamp("accessed_at"),
});

export const shareLinks = pgTable("share_links", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  resourceType: varchar("resource_type", { length: 20 }).notNull(),
  resourceId: varchar("resource_id").notNull(),
  shareCode: varchar("share_code", { length: 20 }).notNull().unique(),
  createdByUserId: varchar("created_by_user_id").notNull().references(() => users.id, { onDelete: 'cascade' }),
  permission: varchar("permission", { length: 20 }).default('view'),
  passwordHash: text("password_hash"),
  accessCount: integer("access_count").default(0),
  maxAccessCount: integer("max_access_count"),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow(),
});

// Add TypeScript types
export type UserProfile = {
  id: string;
  email: string;
  username?: string;
  displayName?: string;
  bio?: string;
  avatarUrl?: string;
  avatar40Url?: string;
  avatar80Url?: string;
  avatar160Url?: string;
  avatar320Url?: string;
  hasCustomAvatar: boolean;
  avatarGeneratedColor?: string;
  isVerified: boolean;
};

export type PromptShare = {
  id: string;
  promptId: string;
  sharedByUserId: string;
  sharedWithUserId: string;
  permission: 'view' | 'copy' | 'remix';
  expiresAt?: string;
  createdAt: string;
};
```

## STEP 2: AVATAR UTILITY FUNCTIONS

**CREATE FILE: `shared/avatarUtils.ts`**

```typescript
export const AVATAR_COLORS = [
  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
  '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'
];

export const USERNAME_RULES = {
  minLength: 3,
  maxLength: 30,
  pattern: /^[a-zA-Z0-9_]+$/,
  reserved: ['admin', 'api', 'www', 'help', 'support', 'settings', 'profile', 'explore'],
  caseSensitive: false
};

export function generateAvatar(displayName: string = '', username: string = '') {
  const name = displayName || username;
  const initials = name
    .split(' ')
    .map(word => word[0]?.toUpperCase() || '')
    .join('')
    .slice(0, 2) || '?';

  const colorIndex = username.charCodeAt(0) % AVATAR_COLORS.length;
  return {
    initials,
    backgroundColor: AVATAR_COLORS[colorIndex],
    textColor: '#FFFFFF'
  };
}

export function validateUsername(username: string): { valid: boolean; error?: string } {
  if (username.length < USERNAME_RULES.minLength) {
    return { valid: false, error: `Username must be at least ${USERNAME_RULES.minLength} characters` };
  }
  if (username.length > USERNAME_RULES.maxLength) {
    return { valid: false, error: `Username cannot exceed ${USERNAME_RULES.maxLength} characters` };
  }
  if (!USERNAME_RULES.pattern.test(username)) {
    return { valid: false, error: 'Username can only contain letters, numbers, and underscores' };
  }
  if (USERNAME_RULES.reserved.includes(username.toLowerCase())) {
    return { valid: false, error: 'This username is reserved' };
  }
  return { valid: true };
}

export function getOptimalAvatarUrl(
  user: { avatar40Url?: string; avatar80Url?: string; avatar160Url?: string; avatar320Url?: string; hasCustomAvatar: boolean },
  size: 'xs' | 'sm' | 'md' | 'lg' | 'xl'
) {
  if (!user.hasCustomAvatar) return null;

  const sizeMap = {
    xs: user.avatar40Url,   // 20px display
    sm: user.avatar80Url,   // 40px display
    md: user.avatar160Url,  // 80px display
    lg: user.avatar160Url,  // 120px display
    xl: user.avatar320Url   // 160px display
  };

  return sizeMap[size];
}
```

## STEP 3: SERVER API ROUTES

**UPDATE FILE: `server/routes.ts`**

Add these routes to the existing Express router:

```typescript
// Add these imports at the top
import { users, prompts, promptShares, shareLinks } from '@shared/schema';
import { validateUsername, generateAvatar } from '@shared/avatarUtils';
import { nanoid } from 'nanoid';
import { eq, and, like, or } from 'drizzle-orm';

// Add after existing routes

// Username management
app.get("/api/users/check-username", async (req, res) => {
  try {
    const { username } = req.query;
    if (!username || typeof username !== 'string') {
      return res.status(400).json({ error: 'Username required' });
    }

    const validation = validateUsername(username);
    if (!validation.valid) {
      return res.status(400).json({ error: validation.error, available: false });
    }

    const existing = await drizzleDB.select().from(users)
      .where(eq(users.username, username.toLowerCase())).limit(1);

    res.json({ available: existing.length === 0, username: username.toLowerCase() });
  } catch (error) {
    console.error('Username check error:', error);
    res.status(500).json({ error: 'Failed to check username' });
  }
});

// User search for @mentions
app.get("/api/users/search", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { q } = req.query;

    if (!q || typeof q !== 'string' || q.length < 2) {
      return res.json({ users: [] });
    }

    const searchTerm = `%${q}%`;
    const searchResults = await drizzleDB.select({
      id: users.id,
      username: users.username,
      displayName: users.displayName,
      avatar40Url: users.avatar40Url,
      avatar80Url: users.avatar80Url,
      hasCustomAvatar: users.hasCustomAvatar,
      avatarGeneratedColor: users.avatarGeneratedColor
    }).from(users)
    .where(
      and(
        or(
          like(users.username, searchTerm),
          like(users.displayName, searchTerm)
        )
      )
    ).limit(10);

    res.json({ users: searchResults });
  } catch (error) {
    console.error('User search error:', error);
    res.status(500).json({ error: 'Search failed' });
  }
});

// Update user profile
app.put("/api/users/profile", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { username, displayName, bio } = req.body;

    let updateData: any = {};

    if (displayName !== undefined) updateData.displayName = displayName;
    if (bio !== undefined) updateData.bio = bio;

    if (username && username !== authUser.username) {
      const validation = validateUsername(username);
      if (!validation.valid) {
        return res.status(400).json({ error: validation.error });
      }

      const existing = await drizzleDB.select().from(users)
        .where(eq(users.username, username.toLowerCase())).limit(1);

      if (existing.length > 0) {
        return res.status(400).json({ error: 'Username already taken' });
      }

      updateData.username = username.toLowerCase();
      updateData.createdUsernameAt = new Date();
    }

    const updated = await drizzleDB.update(users)
      .set(updateData)
      .where(eq(users.id, authUser.userId))
      .returning();

    res.json({ user: updated[0] });
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({ error: 'Failed to update profile' });
  }
});

// Generate avatar
app.post("/api/users/avatar/generate", async (req, res) => {
  try {
    const authUser = requireAuth(req);

    const user = await drizzleDB.select().from(users)
      .where(eq(users.id, authUser.userId)).limit(1);

    if (!user[0]) {
      return res.status(404).json({ error: 'User not found' });
    }

    const avatar = generateAvatar(user[0].displayName || '', user[0].username || '');

    await drizzleDB.update(users)
      .set({
        avatarGeneratedColor: avatar.backgroundColor,
        hasCustomAvatar: false,
        avatarUrl: null,
        avatar40Url: null,
        avatar80Url: null,
        avatar160Url: null,
        avatar320Url: null,
        avatarUpdatedAt: new Date()
      })
      .where(eq(users.id, authUser.userId));

    res.json({ avatar });
  } catch (error) {
    console.error('Avatar generation error:', error);
    res.status(500).json({ error: 'Failed to generate avatar' });
  }
});

// Toggle prompt privacy
app.put("/api/prompts/:id/privacy", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { id } = req.params;
    const { isPublic } = req.body;

    const updated = await drizzleDB.update(prompts)
      .set({ isPublic: !!isPublic })
      .where(and(eq(prompts.id, id), eq(prompts.userId, authUser.userId)))
      .returning();

    if (!updated[0]) {
      return res.status(404).json({ error: 'Prompt not found' });
    }

    res.json({ prompt: updated[0] });
  } catch (error) {
    console.error('Privacy toggle error:', error);
    res.status(500).json({ error: 'Failed to update privacy' });
  }
});

// Share prompt with user
app.post("/api/prompts/:id/share", async (req, res) => {
  try {
    const authUser = requireAuth(req);
    const { id } = req.params;
    const { userId, permission = 'view' } = req.body;

    // Verify prompt ownership
    const prompt = await drizzleDB.select().from(prompts)
      .where(and(eq(prompts.id, id), eq(prompts.userId, authUser.userId))).limit(1);

    if (!prompt[0]) {
      return res.status(404).json({ error: 'Prompt not found' });
    }

    // Create share
    const share = await drizzleDB.insert(promptShares)
      .values({
        promptId: id,
        sharedByUserId: authUser.userId,
        sharedWithUserId: userId,
        permission
      })
      .onConflictDoUpdate({
        target: [promptShares.promptId, promptShares.sharedWithUserId],
        set: { permission, createdAt: new Date() }
      })
      .returning();

    res.json({ share: share[0] });
  } catch (error) {
    console.error('Share error:', error);
    res.status(500).json({ error: 'Failed to share prompt' });
  }
});

// Get shared with me prompts
app.get("/api/prompts/shared-with-me", async (req, res) => {
  try {
    const authUser = requireAuth(req);

    const sharedPrompts = await drizzleDB.select({
      share: promptShares,
      prompt: prompts,
      sharedBy: {
        id: users.id,
        username: users.username,
        displayName: users.displayName,
        avatar40Url: users.avatar40Url,
        hasCustomAvatar: users.hasCustomAvatar,
        avatarGeneratedColor: users.avatarGeneratedColor
      }
    })
    .from(promptShares)
    .innerJoin(prompts, eq(promptShares.promptId, prompts.id))
    .innerJoin(users, eq(promptShares.sharedByUserId, users.id))
    .where(eq(promptShares.sharedWithUserId, authUser.userId))
    .orderBy(promptShares.createdAt);

    res.json({ shares: sharedPrompts });
  } catch (error) {
    console.error('Shared prompts error:', error);
    res.status(500).json({ error: 'Failed to get shared prompts' });
  }
});

// Get public profile
app.get("/api/users/:username", async (req, res) => {
  try {
    const { username } = req.params;

    const user = await drizzleDB.select({
      id: users.id,
      username: users.username,
      displayName: users.displayName,
      bio: users.bio,
      avatar160Url: users.avatar160Url,
      avatar320Url: users.avatar320Url,
      hasCustomAvatar: users.hasCustomAvatar,
      avatarGeneratedColor: users.avatarGeneratedColor,
      isVerified: users.isVerified,
      followerCount: users.followerCount,
      followingCount: users.followingCount,
      createdAt: users.createdAt
    }).from(users)
    .where(eq(users.username, username.toLowerCase())).limit(1);

    if (!user[0]) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.json({ user: user[0] });
  } catch (error) {
    console.error('Profile fetch error:', error);
    res.status(500).json({ error: 'Failed to get profile' });
  }
});
```

## STEP 4: AVATAR DISPLAY COMPONENT

**CREATE FILE: `client/src/components/ui/avatar-display.tsx`**

```tsx
import React from 'react';
import { cn } from '@/lib/utils';
import { generateAvatar, getOptimalAvatarUrl } from '@shared/avatarUtils';

interface AvatarDisplayProps {
  user: {
    username?: string;
    displayName?: string;
    avatar40Url?: string;
    avatar80Url?: string;
    avatar160Url?: string;
    avatar320Url?: string;
    hasCustomAvatar?: boolean;
    avatarGeneratedColor?: string;
  };
  size?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  className?: string;
  onClick?: () => void;
}

const sizeClasses = {
  xs: 'w-5 h-5 text-xs',
  sm: 'w-10 h-10 text-sm',
  md: 'w-20 h-20 text-lg',
  lg: 'w-30 h-30 text-xl',
  xl: 'w-40 h-40 text-2xl'
};

export const AvatarDisplay: React.FC<AvatarDisplayProps> = ({
  user,
  size = 'sm',
  className,
  onClick
}) => {
  const avatarUrl = getOptimalAvatarUrl(user, size);
  const generated = generateAvatar(user.displayName || '', user.username || '');

  if (avatarUrl && user.hasCustomAvatar) {
    return (
      <img
        src={avatarUrl}
        alt={`${user.displayName || user.username || 'User'}'s avatar`}
        className={cn(
          'rounded-full object-cover border-2 border-gray-200 dark:border-gray-700',
          sizeClasses[size],
          onClick && 'cursor-pointer hover:opacity-80',
          className
        )}
        onClick={onClick}
      />
    );
  }

  return (
    <div
      className={cn(
        'rounded-full flex items-center justify-center font-medium border-2 border-gray-200 dark:border-gray-700',
        sizeClasses[size],
        onClick && 'cursor-pointer hover:opacity-80',
        className
      )}
      style={{
        backgroundColor: user.avatarGeneratedColor || generated.backgroundColor,
        color: '#FFFFFF'
      }}
      onClick={onClick}
    >
      {generated.initials}
    </div>
  );
};
```

## STEP 5: USERNAME SETUP MODAL

**CREATE FILE: `client/src/components/dashboard/UsernameSetupModal.tsx`**

```tsx
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useMutation, useQuery } from '@tanstack/react-query';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { useToast } from '@/hooks/use-toast';
import { apiRequest, queryClient } from '@/lib/queryClient';
import { validateUsername } from '@shared/avatarUtils';

const usernameSchema = z.object({
  username: z.string().min(3).max(30).refine((val) => validateUsername(val).valid, {
    message: "Invalid username format"
  })
});

interface UsernameSetupModalProps {
  isOpen: boolean;
  onClose: () => void;
  currentUser: { username?: string; displayName?: string };
}

export const UsernameSetupModal: React.FC<UsernameSetupModalProps> = ({
  isOpen,
  onClose,
  currentUser
}) => {
  const { toast } = useToast();
  const [checkingAvailability, setCheckingAvailability] = useState(false);

  const form = useForm({
    resolver: zodResolver(usernameSchema),
    defaultValues: {
      username: currentUser.username || ''
    }
  });

  const watchedUsername = form.watch('username');

  // Check username availability
  const { data: availabilityCheck } = useQuery({
    queryKey: ['username-check', watchedUsername],
    queryFn: async () => {
      if (!watchedUsername || watchedUsername.length < 3) return null;
      const response = await fetch(`/api/users/check-username?username=${encodeURIComponent(watchedUsername)}`);
      return response.json();
    },
    enabled: watchedUsername?.length >= 3
  });

  const updateProfileMutation = useMutation({
    mutationFn: async (data: { username: string }) => {
      const response = await apiRequest('PUT', '/api/users/profile', data);
      return response.json();
    },
    onSuccess: () => {
      toast({ title: 'Username set successfully!' });
      queryClient.invalidateQueries({ queryKey: ['user'] });
      onClose();
    },
    onError: (error: any) => {
      toast({
        variant: 'destructive',
        title: 'Failed to set username',
        description: error.message
      });
    }
  });

  const handleSubmit = form.handleSubmit((data) => {
    if (availabilityCheck?.available) {
      updateProfileMutation.mutate(data);
    }
  });

  const isUsernameAvailable = availabilityCheck?.available;
  const hasError = availabilityCheck && !availabilityCheck.available;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Choose Your Username</DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <Label htmlFor="username">Username</Label>
            <Input
              id="username"
              {...form.register('username')}
              placeholder="Enter username..."
              className={cn(
                hasError && 'border-red-500',
                isUsernameAvailable && 'border-green-500'
              )}
            />
            {form.formState.errors.username && (
              <p className="text-sm text-red-500 mt-1">
                {form.formState.errors.username.message}
              </p>
            )}
            {hasError && (
              <p className="text-sm text-red-500 mt-1">Username not available</p>
            )}
            {isUsernameAvailable && (
              <p className="text-sm text-green-500 mt-1">Username available!</p>
            )}
          </div>

          <div className="flex justify-end space-x-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Skip for now
            </Button>
            <Button
              type="submit"
              disabled={!isUsernameAvailable || updateProfileMutation.isPending}
            >
              {updateProfileMutation.isPending ? 'Setting...' : 'Set Username'}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  );
};
```

## STEP 6: USER SEARCH COMPONENT

**CREATE FILE: `client/src/components/ui/user-search.tsx`**

```tsx
import React, { useState, useRef, useEffect } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Input } from '@/components/ui/input';
import { AvatarDisplay } from '@/components/ui/avatar-display';
import { cn } from '@/lib/utils';

interface UserSearchProps {
  onUserSelect: (user: any) => void;
  placeholder?: string;
  className?: string;
}

export const UserSearch: React.FC<UserSearchProps> = ({
  onUserSelect,
  placeholder = "Search users...",
  className
}) => {
  const [query, setQuery] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const inputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);

  const { data: searchResults } = useQuery({
    queryKey: ['user-search', query],
    queryFn: async () => {
      if (query.length < 2) return { users: [] };
      const response = await fetch(`/api/users/search?q=${encodeURIComponent(query)}`);
      return response.json();
    },
    enabled: query.length >= 2
  });

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    setQuery(value);
    setIsOpen(value.length >= 2);
  };

  const handleUserSelect = (user: any) => {
    onUserSelect(user);
    setQuery('');
    setIsOpen(false);
    inputRef.current?.blur();
  };

  return (
    <div className={cn("relative", className)}>
      <Input
        ref={inputRef}
        value={query}
        onChange={handleInputChange}
        placeholder={placeholder}
        onFocus={() => query.length >= 2 && setIsOpen(true)}
      />

      {isOpen && searchResults?.users?.length > 0 && (
        <div
          ref={dropdownRef}
          className="absolute top-full left-0 right-0 z-50 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-64 overflow-y-auto mt-1"
        >
          {searchResults.users.map((user: any) => (
            <div
              key={user.id}
              className="flex items-center space-x-3 p-3 hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer border-b border-gray-100 dark:border-gray-600 last:border-0"
              onClick={() => handleUserSelect(user)}
            >
              <AvatarDisplay user={user} size="sm" />
              <div className="flex-1 min-w-0">
                <div className="font-medium text-gray-900 dark:text-gray-100">
                  {user.displayName || user.username}
                </div>
                {user.displayName && user.username && (
                  <div className="text-sm text-gray-500 dark:text-gray-400">
                    @{user.username}
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};
```

## STEP 7: SHARE MODAL COMPONENT

**CREATE FILE: `client/src/components/dashboard/ShareModal.tsx`**

```tsx
import React, { useState } from 'react';
import { useMutation } from '@tanstack/react-query';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { UserSearch } from '@/components/ui/user-search';
import { AvatarDisplay } from '@/components/ui/avatar-display';
import { apiRequest, queryClient } from '@/lib/queryClient';
import { X } from 'lucide-react';

interface ShareModalProps {
  isOpen: boolean;
  onClose: () => void;
  prompt: { id: string; title: string };
}

export const ShareModal: React.FC<ShareModalProps> = ({
  isOpen,
  onClose,
  prompt
}) => {
  const { toast } = useToast();
  const [selectedUsers, setSelectedUsers] = useState<any[]>([]);
  const [permission, setPermission] = useState('view');

  const sharePromptMutation = useMutation({
    mutationFn: async (data: { userId: string; permission: string }) => {
      const response = await apiRequest('POST', `/api/prompts/${prompt.id}/share`, data);
      return response.json();
    },
    onSuccess: () => {
      toast({ title: 'Prompt shared successfully!' });
      queryClient.invalidateQueries({ queryKey: ['shared-prompts'] });
    },
    onError: (error: any) => {
      toast({
        variant: 'destructive',
        title: 'Failed to share prompt',
        description: error.message
      });
    }
  });

  const handleUserSelect = (user: any) => {
    if (!selectedUsers.find(u => u.id === user.id)) {
      setSelectedUsers([...selectedUsers, user]);
    }
  };

  const handleRemoveUser = (userId: string) => {
    setSelectedUsers(selectedUsers.filter(u => u.id !== userId));
  };

  const handleShare = async () => {
    for (const user of selectedUsers) {
      await sharePromptMutation.mutateAsync({ userId: user.id, permission });
    }
    setSelectedUsers([]);
    onClose();
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-md">
        <DialogHeader>
          <DialogTitle>Share "{prompt.title}"</DialogTitle>
        </DialogHeader>

        <div className="space-y-4">
          <div>
            <UserSearch
              onUserSelect={handleUserSelect}
              placeholder="Search users to share with..."
            />
          </div>

          {selectedUsers.length > 0 && (
            <div className="space-y-2">
              <h4 className="text-sm font-medium">Selected Users:</h4>
              {selectedUsers.map(user => (
                <div key={user.id} className="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded">
                  <div className="flex items-center space-x-2">
                    <AvatarDisplay user={user} size="xs" />
                    <span className="text-sm">{user.displayName || user.username}</span>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => handleRemoveUser(user.id)}
                  >
                    <X className="w-4 h-4" />
                  </Button>
                </div>
              ))}
            </div>
          )}

          <div>
            <label className="text-sm font-medium">Permission Level</label>
            <Select value={permission} onValueChange={setPermission}>
              <SelectTrigger>
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="view">View Only</SelectItem>
                <SelectItem value="copy">Can Copy</SelectItem>
                <SelectItem value="remix">Can Remix</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="flex justify-end space-x-2">
            <Button variant="outline" onClick={onClose}>Cancel</Button>
            <Button
              onClick={handleShare}
              disabled={selectedUsers.length === 0 || sharePromptMutation.isPending}
            >
              {sharePromptMutation.isPending ? 'Sharing...' : 'Share'}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};
```

## STEP 8: SHARED WITH ME SECTION

**CREATE FILE: `client/src/components/dashboard/SharedWithMe.tsx`**

```tsx
import React from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { AvatarDisplay } from '@/components/ui/avatar-display';
import { PromptCard } from '@/components/dashboard/PromptCard';
import { Copy, ExternalLink } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';

export const SharedWithMe: React.FC = () => {
  const { toast } = useToast();

  const { data: sharedPrompts, isLoading } = useQuery({
    queryKey: ['shared-with-me'],
    queryFn: async () => {
      const response = await fetch('/api/prompts/shared-with-me', {
        headers: { 'Authorization': `Bearer ${localStorage.getItem('authToken')}` }
      });
      return response.json();
    }
  });

  const handleCopyPrompt = (content: string) => {
    navigator.clipboard.writeText(content);
    toast({ title: 'Prompt copied to clipboard!' });
  };

  if (isLoading) {
    return <div className="text-center py-8">Loading shared prompts...</div>;
  }

  if (!sharedPrompts?.shares?.length) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>Shared with Me</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-gray-500">No prompts have been shared with you yet.</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center space-x-2">
          <span>Shared with Me</span>
          <Badge variant="secondary">{sharedPrompts.shares.length}</Badge>
        </CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {sharedPrompts.shares.map((share: any) => (
            <div key={share.share.id} className="border rounded-lg p-4 space-y-3">
              <div className="flex items-center justify-between">
                <div className="flex items-center space-x-2">
                  <AvatarDisplay user={share.sharedBy} size="sm" />
                  <div>
                    <div className="font-medium">
                      {share.sharedBy.displayName || share.sharedBy.username}
                    </div>
                    <div className="text-sm text-gray-500">
                      shared {new Date(share.share.createdAt).toLocaleDateString()}
                    </div>
                  </div>
                </div>
                <Badge variant="outline">{share.share.permission}</Badge>
              </div>

              <div>
                <h3 className="font-medium">{share.prompt.title}</h3>
                <p className="text-gray-600 dark:text-gray-400 text-sm mt-1 line-clamp-2">
                  {share.prompt.content}
                </p>
              </div>

              <div className="flex items-center space-x-2">
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => handleCopyPrompt(share.prompt.content)}
                  disabled={!['copy', 'remix'].includes(share.share.permission)}
                >
                  <Copy className="w-4 h-4 mr-1" />
                  Copy
                </Button>
                {share.prompt.platform && (
                  <Badge variant="secondary" className="text-xs">
                    {share.prompt.platform}
                  </Badge>
                )}
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};
```

## STEP 9: UPDATE DASHBOARD TO SHOW SHARED SECTION

**UPDATE FILE: `client/src/pages/dashboard.tsx`**

Add this import and component at the top:
```tsx
import { SharedWithMe } from '@/components/dashboard/SharedWithMe';
```

Then add this section to the dashboard layout (after existing prompt sections):
```tsx
{/* Add this section in the dashboard layout */}
<div className="mt-8">
  <SharedWithMe />
</div>
```

## STEP 10: UPDATE PROMPT CARD TO SHOW PRIVACY TOGGLE

**UPDATE FILE: `client/src/components/dashboard/PromptCard.tsx`**

Add these imports:
```tsx
import { ShareModal } from './ShareModal';
import { Switch } from '@/components/ui/switch';
import { Share, Globe, Lock } from 'lucide-react';
import { useMutation } from '@tanstack/react-query';
```

Add these state and mutations inside the PromptCard component:
```tsx
const [showShareModal, setShowShareModal] = useState(false);

const togglePrivacyMutation = useMutation({
  mutationFn: async (isPublic: boolean) => {
    const response = await apiRequest('PUT', `/api/prompts/${prompt.id}/privacy`, { isPublic });
    return response.json();
  },
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['prompts'] });
  }
});
```

Add these controls to the prompt card's action area:
```tsx
{/* Add this to the prompt card actions */}
<div className="flex items-center space-x-2">
  <div className="flex items-center space-x-1">
    {prompt.isPublic ? <Globe className="w-4 h-4" /> : <Lock className="w-4 h-4" />}
    <Switch
      checked={prompt.isPublic}
      onCheckedChange={(checked) => togglePrivacyMutation.mutate(checked)}
      size="sm"
    />
  </div>

  <Button
    variant="ghost"
    size="sm"
    onClick={() => setShowShareModal(true)}
  >
    <Share className="w-4 h-4" />
  </Button>
</div>

<ShareModal
  isOpen={showShareModal}
  onClose={() => setShowShareModal(false)}
  prompt={prompt}
/>
```

## STEP 11: RUN DATABASE MIGRATION

Execute this command in your Replit terminal:
```bash
npm run db:push
```

This will apply all the database schema changes to your PostgreSQL database.

## STEP 12: TEST ALL FEATURES

1. **Start the development server**: `npm run dev`
2. **Test username setup**: Try setting a username in profile settings
3. **Test user search**: Search for users in share modal
4. **Test privacy toggle**: Toggle prompts between public and private
5. **Test sharing**: Share a prompt with another user
6. **Test shared section**: View prompts shared with you

## VERIFICATION CHECKLIST

- [ ] Database migration completed successfully
- [ ] Username system works (availability checking, setting username)
- [ ] Generated avatars display correctly
- [ ] User search returns results with avatars
- [ ] Privacy toggle works on prompts
- [ ] Share modal allows selecting users and sharing
- [ ] "Shared with me" section displays shared prompts
- [ ] All components are properly styled and responsive
- [ ] No TypeScript compilation errors
- [ ] All API endpoints respond correctly

**IMPORTANT**: Test each feature thoroughly before moving to the next phase. This foundation is critical for all subsequent Epic 6 features.

If you encounter any issues, check:
1. Database connection is working
2. All imports are correct
3. API routes are properly registered
4. JWT authentication is working
5. TypeScript types are matching between frontend and backend

This completes Phase 1 of Epic 6 implementation. The username system, avatar support, and basic sharing functionality are now live and ready for Phase 2 enhancements.